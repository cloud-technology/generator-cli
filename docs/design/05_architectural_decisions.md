# 5. 設計決策 (Architectural Decisions)

## 5.1 技術選型決策

### ADR-001: 選擇 Spring Boot 作為核心框架

**決策日期**: 2024-12-01

**狀態**: 已接受 ✅

#### 背景
需要選擇一個成熟的 Java 框架來構建命令列工具，要求具備依賴注入、配置管理、自動配置等功能。

#### 決策
選擇 Spring Boot 3.x 作為核心應用框架

#### 理由
- ✅ 成熟穩定的生態系統
- ✅ 強大的依賴注入容器
- ✅ 豐富的自動配置功能
- ✅ 優秀的測試支援
- ✅ 活躍的社群支援

#### 後果
- 👍 開發效率高，功能豐富
- 👍 良好的可測試性
- 👎 較大的記憶體佔用
- 👎 啟動時間相對較長

---

### ADR-002: 選擇 Spring Shell 作為 CLI 框架

**決策日期**: 2024-12-02

**狀態**: 已接受 ✅

#### 背景
需要提供友好的命令列互動介面，支援互動式問答和參數驗證。

#### 決策
使用 Spring Shell 構建命令列介面

#### 理由
- ✅ 與 Spring Boot 完美整合
- ✅ 支援互動式命令
- ✅ 內建參數驗證
- ✅ 支援命令自動完成
- ✅ 豐富的提示符支援

#### 替代方案
- Apache Commons CLI: 功能較基礎
- Picocli: 功能強大但整合複雜度高

#### 後果
- 👍 用戶體驗優秀
- 👍 開發成本低
- 👎 依賴 Spring 生態系統

---

### ADR-003: 選擇 JOOQ 作為代碼生成器

**決策日期**: 2024-12-03

**狀態**: 已接受 ✅

#### 背景
需要從資料庫結構反向生成 Java 實體類別和資料存取程式碼。

#### 決策
使用 JOOQ Code Generator 生成 POJO 類別

#### 理由
- ✅ 強大的資料庫反向工程能力
- ✅ 支援多種資料庫類型
- ✅ 生成的程式碼品質高
- ✅ 可自定義生成策略
- ✅ 類型安全的 SQL 建構

#### 替代方案
- MyBatis Generator: 主要針對 MyBatis
- Hibernate Tools: 緊耦合 Hibernate

#### 後果
- 👍 生成程式碼品質優秀
- 👍 資料庫支援廣泛
- 👎 學習曲線相對陡峭
- 👎 配置複雜度較高

---

### ADR-004: 使用 Mustache 作為模板引擎

**決策日期**: 2024-12-04

**狀態**: 已接受 ✅

#### 背景
需要選擇模板引擎來生成程式碼檔案，要求語法簡單、邏輯少。

#### 決策
使用 Mustache 作為程式碼生成模板引擎

#### 理由
- ✅ 語法簡單，學習成本低
- ✅ 邏輯少，專注於展示
- ✅ 多語言支援，廣泛使用
- ✅ 良好的效能表現
- ✅ 模板可讀性高

#### 替代方案
- Thymeleaf: 主要用於 Web 模板
- FreeMarker: 功能強大但語法複雜
- Velocity: 已停止維護

#### 後果
- 👍 模板編寫簡單
- 👍 維護成本低
- 👎 複雜邏輯需在 Java 中處理

---

### ADR-005: 採用 Clean Architecture 分層設計

**決策日期**: 2024-12-05

**狀態**: 已接受 ✅

#### 背景
需要設計清晰的軟體架構，確保可維護性和可測試性。

#### 決策
採用 Clean Architecture 原則進行分層設計

#### 理由
- ✅ 依賴方向清晰（外層依賴內層）
- ✅ 業務邏輯獨立於框架
- ✅ 高度可測試性
- ✅ 易於擴展和修改
- ✅ 符合 SOLID 原則

#### 層級劃分
1. **表現層**: Spring Shell CLI
2. **應用層**: 服務協調和流程控制
3. **領域層**: 業務邏輯和生成策略
4. **基礎設施層**: 外部系統整合

#### 後果
- 👍 代碼結構清晰
- 👍 可測試性高
- 👍 易於維護和擴展
- 👎 初期開發成本較高

---

## 5.2 程式碼生成策略決策

### ADR-006: Repository 生成雙階段策略

**決策日期**: 2024-12-10

**狀態**: 已接受 ✅

#### 背景
JOOQ 生成過程中會清理非 JOOQ 生成的檔案，直接生成 Repository 會被刪除。

#### 決策
採用雙階段生成策略：
1. **階段一**: JOOQ 生成 POJO，同時收集表元數據
2. **階段二**: 基於表元數據獨立生成 Repository 介面

#### 理由
- ✅ 避免與 JOOQ 清理機制衝突
- ✅ 保持生成流程的完整性
- ✅ Repository 程式碼更乾淨
- ✅ 符合單一職責原則

#### 實現方式
```java
// 階段一：JOOQ 生成 + 元數據收集
SimpleRepositoryGenerator -> repository-metadata.json

// 階段二：Repository 生成
SpringRepositoryGenerator -> Repository 介面
```

#### 後果
- 👍 解決檔案清理問題
- 👍 Repository 程式碼品質高
- 👎 生成流程較複雜
- 👎 需要中間檔案傳遞資訊

---

### ADR-007: 使用 Record 類別作為值物件

**決策日期**: 2024-12-08

**狀態**: 已接受 ✅

#### 背景
需要傳遞配置資訊和參數，要求不可變性和簡潔性。

#### 決策
使用 Java 14+ Record 類別作為值物件 (Value Objects)

#### 理由
- ✅ 自動生成 equals/hashCode/toString
- ✅ 不可變性保證
- ✅ 語法簡潔
- ✅ 類型安全
- ✅ 良好的可讀性

#### 範例
```java
public record ProjectVo(
    Path projectTempPath,
    BuildTool buildTool,
    String groupId,
    String artifactId,
    String name,
    String description,
    String packageName,
    String jvmVersion,
    Runtime runtime
) {}
```

#### 後果
- 👍 代碼簡潔明瞭
- 👍 編譯期類型檢查
- 👎 需要 Java 14+ 支援

---

## 5.3 資料庫整合決策

### ADR-008: 支援多資料庫類型

**決策日期**: 2024-12-06

**狀態**: 已接受 ✅

#### 背景
企業環境中使用多種不同類型的資料庫系統。

#### 決策
支援主流關聯式資料庫：PostgreSQL, MySQL, Oracle, SQL Server

#### 理由
- ✅ 滿足不同企業需求
- ✅ JOOQ 原生支援多資料庫
- ✅ 增加工具的適用性
- ✅ 符合企業級要求

#### 實現方式
- 使用 JOOQ Meta API 抽象資料庫差異
- 透過 JDBC 驅動適配不同資料庫
- 配置中指定資料庫類型

#### 後果
- 👍 適用範圍廣
- 👍 企業接受度高
- 👎 測試複雜度增加
- 👎 需要維護多種資料庫驅動

---

### ADR-009: 使用 Liquibase 進行資料庫版本控制

**決策日期**: 2024-12-07

**狀態**: 已接受 ✅

#### 背景
需要為生成的專案提供資料庫版本控制能力。

#### 決策
整合 Liquibase 進行資料庫結構版本管理

#### 理由
- ✅ 業界標準的資料庫版本控制工具
- ✅ 支援多種資料庫
- ✅ 豐富的變更類型支援
- ✅ 與 Spring Boot 整合良好
- ✅ 支援回滾功能

#### 替代方案
- Flyway: 功能相對簡單
- 自定義腳本: 維護成本高

#### 後果
- 👍 專業的資料庫版本管理
- 👍 支援多種部署環境
- 👎 配置相對複雜
- 👎 學習成本較高

---

## 5.4 容器化和部署決策

### ADR-010: 提供 Docker 和 Kubernetes 支援

**決策日期**: 2024-12-09

**狀態**: 已接受 ✅

#### 背景
現代應用部署趨向容器化，需要提供相應的配置支援。

#### 決策
自動生成 Docker 和 Kubernetes 部署配置

#### 理由
- ✅ 符合現代化部署趨勢
- ✅ 提高部署效率
- ✅ 支援 DevOps 最佳實務
- ✅ 降低部署複雜度

#### 生成內容
- **Dockerfile**: 多階段構建，最佳化映像大小
- **docker-compose.yml**: 包含應用和資料庫服務
- **Kubernetes YAML**: Deployment, Service, ConfigMap

#### 後果
- 👍 提高開發到部署的效率
- 👍 符合雲原生架構
- 👎 增加生成器複雜度
- 👎 需要維護多種部署模板

---

## 5.5 錯誤處理和恢復決策

### ADR-011: 實作事務性生成機制

**決策日期**: 2024-12-11

**狀態**: 已接受 ✅

#### 背景
生成過程中可能發生錯誤，需要確保系統狀態的一致性。

#### 決策
實作事務性生成機制，支援失敗時的回滾

#### 理由
- ✅ 確保系統狀態一致性
- ✅ 避免產生不完整的專案
- ✅ 提高工具可靠性
- ✅ 符合原子性原則

#### 實作方式
- 記錄所有生成的檔案和目錄
- 發生異常時自動清理
- 提供手動清理命令

#### 後果
- 👍 提高工具可靠性
- 👍 用戶體驗更好
- 👎 實作複雜度增加
- 👎 需要額外的儲存空間記錄狀態

---

## 5.6 性能最佳化決策

### ADR-012: 採用批次處理和並行處理

**決策日期**: 2024-12-12

**狀態**: 已接受 ✅

#### 背景
大型資料庫可能包含數百個資料表，需要最佳化處理性能。

#### 決策
採用批次處理和並行處理提高生成效率

#### 理由
- ✅ 提高大型資料庫處理效率
- ✅ 充分利用多核 CPU
- ✅ 減少記憶體壓力
- ✅ 改善用戶體驗

#### 實作策略
- **批次處理**: 100 個表為一批
- **並行處理**: CPU 核心數個工作執行緒
- **記憶體管理**: 定期清理中間結果

#### 後果
- 👍 處理大型資料庫效率高
- 👍 資源利用率高
- 👎 實作複雜度增加
- 👎 調試難度增加

---

## 5.7 未來擴展決策

### ADR-013: 預留插件擴展機制

**決策日期**: 2024-12-13

**狀態**: 規劃中 🚧

#### 背景
未來可能需要支援更多的生成器類型和自定義需求。

#### 決策
設計插件式架構，支援第三方擴展

#### 理由
- ✅ 增強工具的可擴展性
- ✅ 支援自定義生成需求
- ✅ 社群貢獻友好
- ✅ 符合開放封閉原則

#### 設計方向
- 定義生成器介面標準
- 提供插件載入機制
- 支援配置化插件管理

#### 後果
- 👍 擴展性極強
- 👍 滿足多樣化需求
- 👎 架構複雜度大幅增加
- 👎 需要詳細的插件開發文檔

---

## 5.8 決策追蹤

| ADR | 決策 | 狀態 | 影響等級 | 負責人 |
|-----|------|------|----------|--------|
| ADR-001 | Spring Boot 框架 | ✅ 已接受 | 高 | 架構師 |
| ADR-002 | Spring Shell CLI | ✅ 已接受 | 中 | 開發團隊 |
| ADR-003 | JOOQ 代碼生成 | ✅ 已接受 | 高 | 架構師 |
| ADR-004 | Mustache 模板 | ✅ 已接受 | 中 | 開發團隊 |
| ADR-005 | Clean Architecture | ✅ 已接受 | 高 | 架構師 |
| ADR-006 | Repository 雙階段 | ✅ 已接受 | 中 | 開發團隊 |
| ADR-007 | Record 值物件 | ✅ 已接受 | 低 | 開發團隊 |
| ADR-008 | 多資料庫支援 | ✅ 已接受 | 中 | 架構師 |
| ADR-009 | Liquibase 整合 | ✅ 已接受 | 中 | 開發團隊 |
| ADR-010 | 容器化支援 | ✅ 已接受 | 中 | DevOps |
| ADR-011 | 事務性生成 | ✅ 已接受 | 中 | 開發團隊 |
| ADR-012 | 性能最佳化 | ✅ 已接受 | 中 | 開發團隊 |
| ADR-013 | 插件機制 | 🚧 規劃中 | 高 | 架構師 | 